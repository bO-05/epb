import os
import json
import time
import hmac
import hashlib
import requests
from datetime import datetime
from flask import Flask, request, jsonify
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)

# Configuration
GITHUB_REPO = os.getenv('GITHUB_REPO')  # format: "owner/repo"
GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
MISTRAL_API_KEY = os.getenv('MISTRAL_API_KEY')
POSTMARK_SERVER_TOKEN = os.getenv('POSTMARK_SERVER_TOKEN')
POSTMARK_WEBHOOK_TOKEN = os.getenv('POSTMARK_WEBHOOK_TOKEN')

def verify_postmark_webhook(request_body, signature):
    """Verify the webhook is from Postmark"""
    if not POSTMARK_WEBHOOK_TOKEN:
        return True  # Skip verification if not configured
    
    expected = hmac.new(
        POSTMARK_WEBHOOK_TOKEN.encode(),
        request_body,
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(expected, signature)

def generate_code_with_mistral(instruction):
    """Use Mistral AI to generate code based on instruction"""
    headers = {
        "Authorization": f"Bearer {MISTRAL_API_KEY}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "model": "codestral-latest",
        "messages": [
            {
                "role": "system",
                "content": "You are an expert developer. Generate clean, production-ready code based on the user's requirements. Return the code with clear file paths."
            },
            {
                "role": "user",
                "content": f"Generate code for: {instruction}\n\nReturn format:\n---FILE: path/to/file.py---\ncode here\n---END FILE---"
            }
        ],
        "temperature": 0.3,
        "max_tokens": 4000
    }
    
    response = requests.post(
        "https://api.mistral.ai/v1/chat/completions",
        headers=headers,
        json=payload
    )
    response.raise_for_status()
    
    content = response.json()["choices"][0]["message"]["content"]
    
    # Parse the response to extract files
    files = {}
    current_file = None
    current_content = []
    
    for line in content.split('\n'):
        if line.startswith('---FILE:') and line.endswith('---'):
            if current_file:
                files[current_file] = '\n'.join(current_content)
            current_file = line.replace('---FILE:', '').replace('---', '').strip()
            current_content = []
        elif line == '---END FILE---':
            if current_file:
                files[current_file] = '\n'.join(current_content)
            current_file = None
            current_content = []
        elif current_file:
            current_content.append(line)
    
    return files

def create_github_pr(instruction, files):
    """Create a GitHub PR with the generated files"""
    headers = {
        "Authorization": f"token {GITHUB_TOKEN}",
        "Accept": "application/vnd.github.v3+json"
    }
    
    # Create a unique branch name
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    branch_name = f"email-pr-{timestamp}"
    
    # Get default branch
    repo_info = requests.get(
        f"https://api.github.com/repos/{GITHUB_REPO}",
        headers=headers
    ).json()
    default_branch = repo_info.get('default_branch', 'main')
    
    # Get latest commit SHA from default branch
    ref_response = requests.get(
        f"https://api.github.com/repos/{GITHUB_REPO}/git/refs/heads/{default_branch}",
        headers=headers
    )
    base_sha = ref_response.json()["object"]["sha"]
    
    # Create new branch
    requests.post(
        f"https://api.github.com/repos/{GITHUB_REPO}/git/refs",
        headers=headers,
        json={
            "ref": f"refs/heads/{branch_name}",
            "sha": base_sha
        }
    )
    
    # Create or update files
    for filepath, content in files.items():
        # Check if file exists
        existing_file = requests.get(
            f"https://api.github.com/repos/{GITHUB_REPO}/contents/{filepath}?ref={branch_name}",
            headers=headers
        )
        
        file_data = {
            "message": f"Add/Update {filepath} via email request",
            "content": content.encode('utf-8').hex(),  # GitHub expects base64
            "branch": branch_name
        }
        
        if existing_file.status_code == 200:
            file_data["sha"] = existing_file.json()["sha"]
        
        requests.put(
            f"https://api.github.com/repos/{GITHUB_REPO}/contents/{filepath}",
            headers=headers,
            json=file_data
        )
    
    # Create pull request
    pr_response = requests.post(
        f"https://api.github.com/repos/{GITHUB_REPO}/pulls",
        headers=headers,
        json={
            "title": f"Email Request: {instruction[:60]}...",
            "body": f"""## ðŸ“§ Email-Generated PR

**Request:** {instruction}

**Generated by:** Mistral AI (codestral-latest)
**Triggered via:** Postmark email webhook

---

This PR was automatically generated based on an email request. The AI-based reviewer will analyze the changes shortly.

@coderabbitai please review this PR thoroughly.""",
            "head": branch_name,
            "base": default_branch
        }
    )
    
    pr_data = pr_response.json()
    return pr_data["html_url"], pr_data["number"]

def wait_for_pr_review(pr_number, max_wait=120):
    """Wait for the AI reviewer to complete and get the review"""
    headers = {
        "Authorization": f"token {GITHUB_TOKEN}",
        "Accept": "application/vnd.github.v3+json"
    }
    
    start_time = time.time()
    review_summary = None
    
    while time.time() - start_time < max_wait:
        # Check PR comments
        comments = requests.get(
            f"https://api.github.com/repos/{GITHUB_REPO}/issues/{pr_number}/comments",
            headers=headers
        ).json()
        
        # Look for AI reviewer comment
        for comment in comments:
            if "Summary by" in comment.get("body", "") or "AI-based" in comment.get("body", ""):
                review_summary = comment["body"]
                break
        
        if review_summary:
            break
            
        time.sleep(10)  # Check every 10 seconds
    
    return review_summary or "Review is still in progress. Check the PR for updates."

def send_email_response(to_email, pr_url, review_summary, original_subject):
    """Send response email via Postmark"""
    html_body = f"""
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2>âœ… Pull Request Created Successfully!</h2>
        
        <div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <strong>PR Link:</strong> <a href="{pr_url}" style="color: #0366d6;">{pr_url}</a>
        </div>
        
        <h3>ðŸ¤– AI Review Summary</h3>
        <div style="background-color: #f8f8f8; padding: 15px; border-radius: 5px; border-left: 4px solid #0366d6;">
            <pre style="white-space: pre-wrap; font-family: monospace; font-size: 14px;">{review_summary}</pre>
        </div>
        
        <hr style="margin: 30px 0; border: none; border-top: 1px solid #e0e0e0;">
        
        <p style="color: #666; font-size: 14px;">
            <strong>Next steps:</strong><br>
            â€¢ Review the PR and AI suggestions<br>
            â€¢ Make any necessary adjustments<br>
            â€¢ Merge when ready<br>
            â€¢ Reply to this email with additional instructions
        </p>
    </div>
    """
    
    response = requests.post(
        "https://api.postmarkapp.com/email",
        headers={
            "X-Postmark-Server-Token": POSTMARK_SERVER_TOKEN,
            "Content-Type": "application/json"
        },
        json={
            "From": "ai-coder@yourdomain.com",  # Change this!
            "To": to_email,
            "Subject": f"Re: {original_subject}",
            "HtmlBody": html_body,
            "MessageStream": "outbound"
        }
    )
    response.raise_for_status()

@app.route('/webhook', methods=['POST'])
def handle_postmark_webhook():
    """Handle incoming email from Postmark"""
    # Verify webhook signature
    signature = request.headers.get('X-Postmark-Signature', '')
    if not verify_postmark_webhook(request.data, signature):
        return jsonify({"error": "Invalid signature"}), 403
    
    data = request.json
    
    # Extract email details
    from_email = data.get('FromFull', {}).get('Email', '')
    subject = data.get('Subject', '')
    text_body = data.get('StrippedTextReply') or data.get('TextBody', '')
    
    # Skip if no meaningful content
    if not text_body.strip():
        return jsonify({"status": "ignored", "reason": "empty body"}), 200
    
    try:
        # Generate code using Mistral
        print(f"Generating code for: {text_body}")
        files = generate_code_with_mistral(text_body)
        
        # Create GitHub PR
        print(f"Creating PR with {len(files)} files")
        pr_url, pr_number = create_github_pr(text_body, files)
        
        # Wait for AI review
        print(f"Waiting for AI review on PR #{pr_number}")
        review_summary = wait_for_pr_review(pr_number)
        
        # Send response email
        print(f"Sending response to {from_email}")
        send_email_response(from_email, pr_url, review_summary, subject)
        
        return jsonify({
            "status": "success",
            "pr_url": pr_url,
            "files_created": len(files)
        }), 200
        
    except Exception as e:
        print(f"Error: {str(e)}")
        # Send error email
        send_email_response(
            from_email,
            "",
            f"Error processing request: {str(e)}",
            subject
        )
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint"""
    return jsonify({"status": "healthy", "service": "postmark-mistral-github"}), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)))
